#!/usr/bin/env ruby
$LOAD_PATH.unshift(
  File.join(File.expand_path(File.dirname(__FILE__)), '..', 'lib'))

require 'optparse'
require 'bel_parser'
require 'bel_parser/resource/resource_url_reader'

options = {
  spec: BELParser::Language.specification(
    BELParser::Language.latest_supported_version)
}
OptionParser.new do |opts|
  opts.banner = <<-USAGE.gsub(/^ {4}/, '')
    Validates BEL Script with support for multiple BEL specifications.

    Read from a BEL file.
    usage: #$PROGRAM_NAME --file [FILE]

    Read from standard input.
    usage: #$PROGRAM_NAME
  USAGE

  opts.on('-f', '--file FILE', 'BEL script file to read.') do |bel|
    options[:file] = bel
  end

  opts.on(
    '-s',
    '--specification VERSION',
    'BEL specification version (e.g. 1.0, 2.0)') do |spec|

    unless BELParser::Language.defines_version?(spec)
      $stderr.puts %(Invalid BEL specification "#{spec}")
      exit 1
    end

    options[:spec] = BELParser::Language.specification(spec)
  end

  opts.on(
    '-r',
    '--[no-]reuse-resource-databases',
    'Enable to reuse resource databases if they exist.') do |reuse|

    options[:reuse] = reuse
  end
end.parse!

file, spec = options.values_at(:file, :spec)
io =
  if file
    File.open(file, external_encoding: 'UTF-8')
  else
    $stdin
  end

def select(list, cls)
  list.select { |item| item.is_a?(cls) }
end

def report(line_number, ast, errors, warnings)
  log = !errors.empty? || !warnings.empty?
  if log
    puts "On line #{line_number} for #{ast.type}"
    puts "  Errors:"
    errors.each do |err|
      puts "    #{err}"
    end
    puts "  Warnings:"
    warnings.each do |warn|
      puts "    #{warn}"
    end
  end
end

SYN_ERR  = BELParser::Language::Syntax::SyntaxError
SYN_WARN = BELParser::Language::Syntax::SyntaxWarning
SEM_WARN = BELParser::Language::Semantics::SemanticsWarning

rr = BELParser::Resource::ResourceURLReader.new(options[:reuse])
namespaces = Hash[
  ARGV.map do |ns|
    prefix, identifier = ns.split('=')
    dataset            = rr.retrieve_resource(identifier)
    dataset ? [prefix, dataset] : nil
  end.compact
]

initial_state = {
  resource_reader:       rr,
  specification:         spec,
  namespace_definitions: namespaces
}

BELParser::Script::Validator
.new(initial_state)
.each(io) do |(line_number, line, ast, syntax_results, state)|
  errors   = select(syntax_results, SYN_ERR)
  warnings =
    select(syntax_results, SYN_WARN) +
    select(syntax_results, SEM_WARN)

  report(line_number, ast, errors, warnings)

  unless errors.empty?
    puts "Exiting due to error on line #{line_number}: #{line}"
    exit 1
  end
end
