require 'ast'
require 'bel/language/version1'
require 'bel/language/semantic_ast'
require 'bel/parsers/expression'

include AST::Sexp
FX = BEL::Language::Version1::Functions

MATCHES = [
  {
    test: 'match valid modified protein: p(E:P,F:pmod)p',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'p')),
        s(:argument,
          s(:parameter,
            s(:prefix,
              s(:identifier, 'HGNC')),
            s(:value,
              s(:identifier, 'AKT1')))),
        s(:argument,
          s(:term,
            s(:function,
              s(:identifier, 'pmod')),
            s(:argument,
              s(:parameter,
                s(:prefix, nil),
                s(:value,
                  s(:identifier, 'P')))),
            s(:argument,
              s(:parameter,
                s(:prefix, nil),
                s(:value,
                  s(:identifier, 'S')))),
            s(:argument,
              s(:parameter,
                s(:prefix, nil),
                s(:value,
                  s(:identifier, '320'))))))),
    semantic: FX::ProteinAbundance::Signatures::ProteinAbundanceWithProteinModificationSignature.semantic_ast
  },
  {
    test: 'match valid protein abundance: p(E:P)p',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'p')),
        s(:argument,
          s(:parameter,
            s(:prefix,
              s(:identifier, 'HGNC')),
            s(:value,
              s(:identifier, 'AKT1'))))),
    semantic: FX::ProteinAbundance::Signatures::ProteinAbundanceSignature.semantic_ast
  },
  {
    test: 'protein mod with covalent, amino acid, and position: pmod(E:*,E:*,E:*)pmod',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'pmod')),
        s(:argument,
          s(:parameter,
            s(:prefix, nil),
            s(:value,
              s(:identifier, 'Phosphorylation')))),
        s(:argument,
          s(:parameter,
            s(:prefix, nil),
            s(:value,
              s(:identifier, 'Arginine')))),
        s(:argument,
          s(:parameter,
            s(:prefix, nil),
            s(:value,
              s(:identifier, '300'))))),
    semantic: FX::ProteinModification::Signatures::ProteinModificationWithCovalentAminoPositionSignature.semantic_ast
  },
  {
    test: 'protein mod with covalent and amino acid: pmod(E:*,E:*)pmod',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'pmod')),
        s(:argument,
          s(:parameter,
            s(:prefix, nil),
            s(:value,
              s(:identifier, 'Phosphorylation')))),
        s(:argument,
          s(:parameter,
            s(:prefix, nil),
            s(:value,
              s(:identifier, 'Arginine'))))),
    semantic: FX::ProteinModification::Signatures::ProteinModificationWithCovalentAminoSignature.semantic_ast
  },
  {
    test: 'match valid protein mod with covalent type: pmod(E:*)pmod',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'pmod')),
        s(:argument,
          s(:parameter,
            s(:prefix, nil),
            s(:value,
              s(:identifier, 'Phosphorylation'))))),
    semantic: FX::ProteinModification::Signatures::ProteinModificationWithCovalentSignature.semantic_ast
  },
  {
    test: 'match composed complex: complex(F:A...)pmod',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'complex')),
        s(:argument,
          s(:term,
            s(:function,
              s(:identifier, 'p')),
            s(:argument,
              s(:parameter,
                s(:prefix,
                  s(:identifier, 'HGNC')),
                s(:value,
                  s(:identifier, 'TIMP3'))))))),
    semantic: FX::ComplexAbundance::Signatures::ComposedComplexAbundanceSignature.semantic_ast
  },
  {
    test: 'match composed complex: complex(F:A...)pmod',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'complex')),
        s(:argument,
          s(:term,
            s(:function,
              s(:identifier, 'p')),
            s(:argument,
              s(:parameter,
                s(:prefix,
                  s(:identifier, 'HGNC')),
                s(:value,
                  s(:identifier, 'TIMP3')))))),
        s(:argument,
          s(:term,
            s(:function,
              s(:identifier, 'p')),
            s(:argument,
              s(:parameter,
                s(:prefix,
                  s(:identifier, 'HGNC')),
                s(:value,
                  s(:identifier, 'KDR'))))))),
    semantic: FX::ComplexAbundance::Signatures::ComposedComplexAbundanceSignature.semantic_ast
  },
  {
    test: 'match composed complex: complex(F:A...)pmod',
    input:
      s(:term,
        s(:function,
          s(:identifier, 'complex')),
        s(:argument,
          s(:term,
            s(:function,
              s(:identifier, 'p')),
            s(:argument,
              s(:parameter,
                s(:prefix,
                  s(:identifier, 'HGNC')),
                s(:value,
                  s(:identifier, 'ADRB2')))))),
        s(:argument,
          s(:term,
            s(:function,
              s(:identifier, 'p')),
            s(:argument,
              s(:parameter,
                s(:prefix,
                  s(:identifier, 'SFAM')),
                s(:value,
                  s(:string, '"PDE4 Family"')))))),
        s(:argument,
          s(:term,
            s(:function,
              s(:identifier, 'p')),
            s(:argument,
              s(:parameter,
                s(:prefix,
                  s(:identifier, 'SFAM')),
                s(:value,
                  s(:string, '"ARRB Family"'))))))),
    semantic: FX::ComplexAbundance::Signatures::ComposedComplexAbundanceSignature.semantic_ast
  }
].freeze
