/* Automatically generated by Kelbt from "klparse.kl".
 *
 * Parts of this file are copied from Kelbt source covered by the GNU
 * GPL. As a special exception, you may use the parts of this file copied
 * from Kelbt source without restriction. The remainder is derived from
 * "klparse.kl" and inherits the copyright status of that file.
 */

#line 1 "klparse.kl"
/*
 *  Copyright 2006 Adrian Thurston <thurston@complang.org>
 */

/*  This file is part of Kelbt.
 *
 *  Kelbt is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 * 
 *  Kelbt is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with Kelbt; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

#include "klparse.h"
#include "kelbt.h"
#include <iostream>

using std::cout;
using std::cerr;
using std::endl;

#line 49 "klparse.kh"
#line 69 "klparse.kh"
#line 318 "klparse.kl"


#line 45 "klparse.cpp"
struct Parser_Lel_inline_block_item
{
#line 193 "klparse.kl"

	InlineItem *inlineItem;
	InputLoc loc;


#line 52 "klparse.cpp"
};

struct Parser_Lel_inline_list
{
#line 171 "klparse.kl"

	InlineList *inlineList;
	InputLoc loc;


#line 63 "klparse.cpp"
};

struct Parser_Lel_opt_class
{
#line 140 "klparse.kl"

	bool isClass;


#line 73 "klparse.cpp"
};

struct Parser_Lel_opt_commit
{
#line 250 "klparse.kl"

	bool commit;


#line 83 "klparse.cpp"
};

struct Parser_Lel_opt_inline_block
{
#line 280 "klparse.kl"

	InlineBlock *inlineBlock;


#line 93 "klparse.cpp"
};

struct Parser_Lel_opt_prior
{
#line 265 "klparse.kl"

	int priorVal;


#line 103 "klparse.cpp"
};

struct Parser_Lel_prod_el
{
#line 232 "klparse.kl"

	Factor *factor;


#line 113 "klparse.cpp"
};

struct Parser_Lel_prod_el_list
{
#line 214 "klparse.kl"

	ProdElList *prodElList;


#line 123 "klparse.cpp"
};

union Parser_UserData
{
	struct Parser_Lel_inline_block_item inline_block_item;
	struct Parser_Lel_inline_list inline_list;
	struct Parser_Lel_opt_class opt_class;
	struct Parser_Lel_opt_commit opt_commit;
	struct Parser_Lel_opt_inline_block opt_inline_block;
	struct Parser_Lel_opt_prior opt_prior;
	struct Parser_Lel_prod_el prod_el;
	struct Parser_Lel_prod_el_list prod_el_list;
	struct Token token;
};

struct Parser_LangEl
{
	char *file;
	int line;
	int type;
	int reduction;
	int state;
	int causeReduce;
	union Parser_UserData user;
	unsigned int retry;
	struct Parser_LangEl *next, *child, *prev;
};

struct Parser_Block
{
	struct Parser_LangEl data[8128];
	struct Parser_Block *next;
};

#line 160 "klparse.cpp"
unsigned int Parser_startState = 0;

char Parser_indicies[] = {
	50, 50, -1, 50, -1, 50, 50, -1, 
	-1, -1, -1, -1, 50, -1, 50, 1, 
	0, 93, 3, 4, -1, 5, -1, 7, 
	2, -1, -1, -1, -1, -1, 6, -1, 
	48, -1, -1, 49, 85, 86, 87, 88, 
	89, 90, 91, 92, 16, 83, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	83, 83, 11, -1, -1, 9, -1, -1, 
	-1, 56, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8, 55, -1, 10, 61, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 12, 61, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 62, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 14, 17, 15, 
	20, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 53, 
	61, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 62, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 19, 
	79, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 22, 79, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 21, 67, 68, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 18, 66, 
	24, 23, 25, 64, 70, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 70, 70, 70, 
	70, -1, -1, -1, -1, -1, 70, -1, 
	70, -1, -1, -1, -1, 70, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 26, 51, 84, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 84, 84, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 67, 68, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	65, 27, 56, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 54, 81, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 30, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 29, 67, 68, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 28, 66, 31, 67, 
	68, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 32, 66, 67, 68, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 33, 66, 73, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	36, 73, 73, 73, -1, -1, -1, -1, 
	-1, 38, -1, 76, -1, -1, -1, -1, 
	76, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	34, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 69, 37, 57, 80, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 80, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 67, 68, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 65, 
	58, 67, 68, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 39, 66, 60, 59, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 67, 68, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	65, 63, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	67, 68, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 65, 77, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 42, 77, 
	77, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 41, 74, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 74, 74, 74, -1, -1, -1, -1, 
	-1, -1, -1, 74, -1, -1, -1, -1, 
	74, 35, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 73, -1, -1, -1, 
	-1, 73, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 43, 40, 82, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 67, 68, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 65, 44, 79, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 22, 79, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 46, 67, 68, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 45, 66, 71, 
	-1, -1, -1, -1, 72, 75, 78, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 78, 78, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 67, 68, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	65, 81, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 30, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 47, 52, 
};

unsigned char Parser_keys[] = {
	137, 153, 151, 151, 137, 162, 58, 58, 
	59, 171, 131, 170, 131, 170, 150, 150, 
	143, 143, 44, 59, 131, 170, 59, 166, 
	146, 173, 143, 143, 139, 139, 143, 143, 
	59, 59, 59, 163, 59, 59, 59, 173, 
	143, 143, 143, 169, 59, 167, 146, 173, 
	143, 143, 146, 173, 146, 173, 59, 175, 
	59, 59, 59, 173, 59, 59, 146, 173, 
	59, 59, 59, 173, 59, 173, 59, 165, 
	59, 148, 132, 164, 40, 40, 59, 173, 
	145, 145, 59, 166, 146, 173, 143, 148, 
	41, 41, 59, 173, 59, 167, 59, 59, 
	0, 0
};

unsigned short Parser_offsets[] = {
	0, 17, 18, 44, 45, 158, 198, 238, 
	239, 240, 256, 296, 404, 432, 433, 434, 
	435, 436, 541, 542, 657, 658, 685, 794, 
	822, 823, 851, 879, 996, 997, 1112, 1113, 
	1141, 1142, 1257, 1372, 1479, 1569, 1602, 1603, 
	1718, 1719, 1827, 1855, 1861, 1862, 1977, 2086, 
	2087
};

unsigned char Parser_targs[] = {
	1, 2, 3, 4, 5, 6, 7, 8, 
	9, 10, 11, 12, 13, 14, 15, 16, 
	17, 18, 19, 20, 21, 22, 23, 24, 
	25, 26, 27, 28, 29, 30, 31, 32, 
	33, 34, 35, 36, 36, 37, 38, 39, 
	40, 41, 42, 43, 44, 45, 46, 47, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48
};

unsigned int Parser_actInds[] = {
	0, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 22, 24, 26, 29, 31, 
	33, 35, 37, 39, 41, 43, 45, 47, 
	49, 51, 53, 55, 57, 59, 61, 63, 
	65, 67, 69, 71, 73, 76, 78, 80, 
	82, 84, 86, 88, 90, 92, 94, 96, 
	98, 100, 102, 104, 106, 108, 110, 112, 
	114, 116, 118, 120, 122, 124, 126, 128, 
	130, 132, 134, 136, 138, 140, 142, 144, 
	146, 148, 150, 152, 154, 156, 158, 160, 
	162, 164, 166, 168, 170, 172, 174, 176, 
	178, 180, 182, 184, 186, 188
};

unsigned int Parser_actions[] = {
	1, 0, 1, 0, 1, 0, 1, 0, 
	1, 0, 1, 0, 1, 0, 1, 0, 
	1, 0, 1, 0, 1, 0, 1, 0, 
	1, 0, 90, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 1, 0, 1, 0, 1, 0, 1, 
	0, 146, 1, 0, 1, 0, 1, 0, 
	1, 0, 1, 0, 1, 0, 1, 0, 
	1, 0, 1, 0, 1, 0, 1, 0, 
	1, 0, 2, 0, 7, 0, 10, 0, 
	47, 0, 51, 0, 55, 0, 59, 0, 
	63, 0, 67, 0, 71, 0, 75, 0, 
	79, 0, 83, 0, 87, 0, 90, 0, 
	95, 0, 99, 0, 103, 0, 107, 0, 
	111, 0, 115, 0, 119, 0, 122, 0, 
	127, 0, 131, 0, 134, 0, 138, 0, 
	143, 0, 146, 0, 150, 0, 154, 0, 
	158, 0, 162, 0, 166, 0, 170, 0, 
	174, 0, 178, 0, 15, 0, 19, 0, 
	23, 0, 27, 0, 31, 0, 35, 0, 
	39, 0, 43, 0, 1, 0
};

int Parser_commitLen[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	1, 1, 1, 1, 1, 2
};

char Parser_prodLengths[] = {
	1, 2, 0, 1, 1, 1, 1, 1, 
	1, 1, 1, 3, 8, 3, 3, 1, 
	1, 5, 5, 5, 5, 1, 0, 5, 
	3, 2, 1, 1, 1, 2, 0, 3, 
	3, 0, 1, 4, 0, 0, 2, 0, 
	2, 0, 2, 0, 2, 1
};

unsigned char Parser_prodLhsIds[] = {
	153, 152, 152, 154, 154, 154, 154, 154, 
	154, 154, 154, 161, 155, 156, 168, 168, 
	169, 157, 158, 159, 159, 170, 170, 160, 
	162, 172, 172, 173, 173, 163, 163, 174, 
	174, 164, 164, 175, 175, 165, 165, 166, 
	166, 167, 167, 171, 171, 176
};

const char *Parser_prodNames[] = {
	"start-1",
	"statement_list-1",
	"statement_list-2",
	"statement-1",
	"statement-2",
	"statement-3",
	"statement-4",
	"statement-5",
	"statement-6",
	"statement-7",
	"statement-8",
	"access_stmt-1",
	"production_stmt-1",
	"token_stmt-1",
	"token_list-1",
	"token_list-2",
	"token_list_word-1",
	"token_uses_stmt-1",
	"translate_stmt-1",
	"nonterm_stmt-1",
	"nonterm_stmt-2",
	"opt_class-1",
	"opt_class-2",
	"type_stmt-1",
	"shortest_stmt-1",
	"inline_list-1",
	"inline_list-2",
	"inline_block_item-1",
	"inline_block_item-2",
	"prod_el_list-1",
	"prod_el_list-2",
	"prod_el-1",
	"prod_el-2",
	"opt_commit-1",
	"opt_commit-2",
	"opt_prior-1",
	"opt_prior-2",
	"opt_reduction-1",
	"opt_reduction-2",
	"opt_undo-1",
	"opt_undo-2",
	"opt_final-1",
	"opt_final-2",
	"opt_translate-1",
	"opt_translate-2",
	"_start-1"
};

const char *Parser_lelNames[] = {
	"D-0",
	"D-1",
	"D-2",
	"D-3",
	"D-4",
	"D-5",
	"D-6",
	"D-7",
	"D-8",
	"D-9",
	"D-10",
	"D-11",
	"D-12",
	"D-13",
	"D-14",
	"D-15",
	"D-16",
	"D-17",
	"D-18",
	"D-19",
	"D-20",
	"D-21",
	"D-22",
	"D-23",
	"D-24",
	"D-25",
	"D-26",
	"D-27",
	"D-28",
	"D-29",
	"D-30",
	"D-31",
	"D-32",
	"!",
	"\"",
	"#",
	"$",
	"%",
	"&",
	"'",
	"(",
	")",
	"*",
	"+",
	",",
	"-",
	".",
	"/",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	":",
	";",
	"<",
	"=",
	">",
	"?",
	"@",
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"[",
	"\\",
	"]",
	"^",
	"_",
	"`",
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g",
	"h",
	"i",
	"j",
	"k",
	"l",
	"m",
	"n",
	"o",
	"p",
	"q",
	"r",
	"s",
	"t",
	"u",
	"v",
	"w",
	"x",
	"y",
	"z",
	"{",
	"|",
	"}",
	"~",
	"D-127",
	"KW_Parser",
	"KW_Include",
	"KW_Write",
	"KW_Class",
	"KW_Commit",
	"KW_Try",
	"KW_Undo",
	"KW_Final",
	"KW_Translate",
	"KW_Token",
	"KW_NonTerm",
	"KW_Uses",
	"KW_Type",
	"KW_Pri",
	"KW_Shortest",
	"TK_Word",
	"TK_String",
	"TK_Number",
	"TK_Inline",
	"TK_Reference",
	"TK_Literal",
	"KW_Access",
	"TK_AccessData",
	"Parser_tk_eof",
	"statement_list",
	"start",
	"statement",
	"production_stmt",
	"token_stmt",
	"token_uses_stmt",
	"translate_stmt",
	"nonterm_stmt",
	"type_stmt",
	"access_stmt",
	"shortest_stmt",
	"prod_el_list",
	"opt_commit",
	"opt_reduction",
	"opt_undo",
	"opt_final",
	"token_list",
	"token_list_word",
	"opt_class",
	"opt_translate",
	"inline_list",
	"inline_block_item",
	"prod_el",
	"opt_prior",
	"_start"
};

#line 323 "klparse.kl"


void Parser::init()
{
	#line 777 "klparse.cpp"
	curs = Parser_startState;
	pool = 0;
	block = (struct Parser_Block*) malloc( sizeof(struct Parser_Block) );
	block->next = 0;
	freshEl = block->data;
	#ifdef KELBT_LOG_ACTIONS
	cerr << "allocating 8128 LangEls" << endl;
	#endif
	stackTop = freshEl;
	stackTop->type = 0;
	stackTop->state = -1;
	stackTop->next = 0;
	stackTop->child = 0;
	stackTop->causeReduce = 0;
	freshPos = 1;
	lastFinal = stackTop;
	numRetry = 0;
	numNodes = 0;
	errCount = 0;
#line 328 "klparse.kl"
}

TypeDef *Parser::getTypeDef( char *data )
{
	TypeDefMapEl *inMap = 0, *inserted;
	inserted = pd.typeDefMap.insert( data, &inMap );
	if ( inserted != 0 )
		inserted->value = new TypeDef( data );
	return inMap->value;
}

int Parser::parseLangEl( int type, const Token *token )
{
	#line 811 "klparse.cpp"
#define reject() induceReject = 1

	int pos, targState;
	unsigned int *action;
	int rhsLen;
	struct Parser_LangEl *rhs[32];
	struct Parser_LangEl *lel = 0;
	struct Parser_LangEl *input = 0;
	struct Parser_LangEl *queue = 0;
	char induceReject;

	if ( curs < 0 )
		return 0;

	if ( pool == 0 ) {
		if ( freshPos == 8128 ) {
			struct Parser_Block* newBlock  = (struct Parser_Block*) malloc( sizeof(struct Parser_Block) );
			newBlock->next = block;
			block = newBlock;
			freshEl = newBlock->data;
			#ifdef KELBT_LOG_ACTIONS
			cerr << "allocating 8128 LangEls" << endl;
			#endif
			freshPos = 0;
		}
		queue = freshEl + freshPos++;
	}
	else {
		queue = pool;
		pool = pool->next;
	}
	numNodes += 1;

	queue->type = type;
	queue->user.token = *token;
	queue->next = 0;
	queue->retry = 0;
	queue->child = 0;
	queue->causeReduce = 0;

again:
	if ( input == 0 ) {
		if ( queue == 0 )
			goto _out;

		input = queue;
		queue = queue->next;
		input->next = 0;
	}

	lel = input;
	if ( lel->type < Parser_keys[curs<<1] || lel->type > Parser_keys[(curs<<1)+1] )
		goto parseError;

	pos = Parser_indicies[Parser_offsets[curs] + (lel->type - Parser_keys[curs<<1])];
	if ( pos < 0 )
		goto parseError;

	induceReject = 0;
	targState = Parser_targs[pos];
	action = Parser_actions + Parser_actInds[pos];
	if ( lel->retry & 0x0000ffff )
		action += (lel->retry & 0x0000ffff);

	if ( *action & 0x1 ) {
		#ifdef KELBT_LOG_ACTIONS
		cerr << "shifted: " << Parser_lelNames[lel->type];
		#endif
		input = input->next;
		lel->state = curs;
		lel->next = stackTop;
		stackTop = lel;

		if ( action[1] == 0 )
			lel->retry &= 0xffff0000;
		else {
			lel->retry += 1;
			numRetry += 1;
			#ifdef KELBT_LOG_ACTIONS
			cerr << " retry: " << stackTop;
			#endif
		}
		#ifdef KELBT_LOG_ACTIONS
		cerr << endl;
		#endif
	}

	if ( Parser_commitLen[pos] != 0 ) {
		struct Parser_LangEl *commitHead = stackTop, *lel;
		int sp = 0, doExec = 0;
		#ifdef KELBT_LOG_ACTIONS
		cerr << "commit encountered, executing final actions" << endl;
		#endif
		if ( Parser_commitLen[pos] < 0 )
			commitHead = commitHead->next;

		lel = commitHead;

commit_head:
		if ( lel == lastFinal ) {
			doExec = 1;
			goto commit_base;
		}

		if ( lel->next != 0 ) {
			sp += 1;
			lel->next->prev = lel;
			lel = lel->next;
			lel->retry = 0;
			goto commit_head;
		}

commit_reverse:

		if ( lel->child != 0 ) {
			sp += 1;
			lel->child->prev = lel;
			lel = lel->child;
			lel->retry = 1;
			goto commit_head;
		}

commit_upwards:

		if ( doExec ) {
			if ( lel->type < 152 ) {
			}
			else {
				struct Parser_LangEl *redLel = lel;
				if ( redLel->child != 0 ) {
					int r = Parser_prodLengths[redLel->reduction] - 1;
					struct Parser_LangEl *rhsEl = redLel->child;
					while ( rhsEl != 0 ) {
						rhs[r--] = rhsEl;
						rhsEl = rhsEl->next;
					}
				}
switch ( lel->reduction ) {
case 11: {
Token *__ref0 = (Token*)&rhs[1]->user.token;
#line 52 "klparse.kl"

		pd.access = (__ref0)->data;
	

#line 955 "klparse.cpp"
} break;
case 12: {
Token *__ref0 = (Token*)&rhs[0]->user.token;
Token *__ref1 = (Token*)&rhs[0]->user.token;
Token *__ref2 = (Token*)&rhs[0]->user.token;
Token *__ref3 = (Token*)&rhs[0]->user.token;
Parser_Lel_prod_el_list *__ref4 = (Parser_Lel_prod_el_list*)&rhs[2]->user.prod_el_list;
Parser_Lel_opt_commit *__ref5 = (Parser_Lel_opt_commit*)&rhs[3]->user.opt_commit;
Parser_Lel_opt_inline_block *__ref6 = (Parser_Lel_opt_inline_block*)&rhs[4]->user.opt_inline_block;
Parser_Lel_opt_inline_block *__ref7 = (Parser_Lel_opt_inline_block*)&rhs[5]->user.opt_inline_block;
Parser_Lel_opt_inline_block *__ref8 = (Parser_Lel_opt_inline_block*)&rhs[6]->user.opt_inline_block;
Token *__ref9 = (Token*)&rhs[0]->user.token;
#line 59 "klparse.kl"

		/* Get the language element. */
		KlangEl *prodName = getKlangEl( &pd, (__ref0)->data, KlangEl::NonTerm );

		/* Check that the element wasn't previously defined as something else. */
		if ( prodName->type != KlangEl::Unknown 
				&& prodName->type != KlangEl::NonTerm )
		{
			error((__ref1)->loc) << "'" << (__ref2)->data << "' already defined as something else" << endl;
		}
		else {
			prodName->type = KlangEl::NonTerm;
			Definition *newDef = new Definition( (__ref3)->loc, prodName, (__ref4)->prodElList,
					(__ref5)->commit, (__ref6)->inlineBlock, (__ref7)->inlineBlock, (__ref8)->inlineBlock, 
					pd.prodList.length(), Definition::Production );
			prodName->defList.append( newDef );
			pd.prodList.append( newDef );

			/* Start machine will trigger code generation. */
			if ( strcmp((__ref9)->data, startDefName) == 0 )
				sawStart = true;

			newDef->rhsLelVect = langElVect;
			newDef->rhsFactorVect = factorVect;
			langElVect.empty();
			factorVect.empty();
		}
	

#line 998 "klparse.cpp"
} break;
case 16: {
Token *__ref0 = (Token*)&rhs[0]->user.token;
Token *__ref1 = (Token*)&rhs[0]->user.token;
Token *__ref2 = (Token*)&rhs[0]->user.token;
#line 94 "klparse.kl"

		/* Token name must be unique. */
		KlangEl *tokName = getKlangEl( &pd, (__ref0)->data, KlangEl::Term );
		if ( tokName->type != KlangEl::Unknown && tokName->type != KlangEl::Term )
			error((__ref1)->loc) << "'" << (__ref2) << "' already defined as something else" << endl;
		tokName->type = KlangEl::Term;
	

#line 1013 "klparse.cpp"
} break;
case 17: {
Token *__ref0 = (Token*)&rhs[3]->user.token;
Parser_Lel_opt_class *__ref1 = (Parser_Lel_opt_class*)&rhs[2]->user.opt_class;
#line 103 "klparse.kl"

		pd.tokenStruct = (__ref0)->data;
		pd.tokenIsClass = (__ref1)->isClass;
	

#line 1024 "klparse.cpp"
} break;
case 18: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&rhs[1]->user.opt_inline_block;
Parser_Lel_opt_inline_block *__ref1 = (Parser_Lel_opt_inline_block*)&rhs[2]->user.opt_inline_block;
Parser_Lel_opt_inline_block *__ref2 = (Parser_Lel_opt_inline_block*)&rhs[3]->user.opt_inline_block;
#line 110 "klparse.kl"

		pd.translateBlock = (__ref0)->inlineBlock;
		pd.undoTransBlock = (__ref1)->inlineBlock;
		pd.tokenFinalBlock = (__ref2)->inlineBlock;
	

#line 1037 "klparse.cpp"
} break;
case 19: {
Token *__ref0 = (Token*)&rhs[2]->user.token;
Token *__ref1 = (Token*)&rhs[2]->user.token;
Parser_Lel_inline_list *__ref2 = (Parser_Lel_inline_list*)&rhs[3]->user.inline_list;
Token *__ref3 = (Token*)&rhs[2]->user.token;
Token *__ref4 = (Token*)&rhs[2]->user.token;
Token *__ref5 = (Token*)&rhs[2]->user.token;
Parser_Lel_opt_class *__ref6 = (Parser_Lel_opt_class*)&rhs[1]->user.opt_class;
#line 118 "klparse.kl"

		/* Create/get the nonterminal. */
		KlangEl *nonTerm = getKlangEl( &pd, (__ref0)->data, KlangEl::NonTerm );

		/* Make a new inline block. */
		InlineBlock *typeBlock = new InlineBlock( (__ref1)->loc, (__ref2)->inlineList );

		/* Create/get the typedef. */
		TypeDef *typeDef = getTypeDef( (__ref3)->data );
		nonTerm->typeDef = typeDef;

		/* The typeDef should not already exist. */
		if ( typeDef->typeBlock != 0 )
			error((__ref4)->loc) << "redefintion of nonterminal type " << (__ref5)->data << endl;
		else {
			typeDef->typeBlock = typeBlock;
			typeDef->isClass = (__ref6)->isClass;
		}
	

#line 1068 "klparse.cpp"
} break;
case 20: {
Token *__ref0 = (Token*)&rhs[1]->user.token;
Token *__ref1 = (Token*)&rhs[3]->user.token;
#line 140 "klparse.kl"

		KlangEl *nonTerm = getKlangEl( &pd, (__ref0)->data, KlangEl::NonTerm );
		nonTerm->typeDef = getTypeDef( (__ref1)->data );
	

#line 1079 "klparse.cpp"
} break;
case 21: {
Parser_Lel_opt_class *__ref0 = (Parser_Lel_opt_class*)&redLel->user.opt_class;
#line 150 "klparse.kl"
 (__ref0)->isClass = true; 

#line 1086 "klparse.cpp"
} break;
case 22: {
Parser_Lel_opt_class *__ref0 = (Parser_Lel_opt_class*)&redLel->user.opt_class;
#line 151 "klparse.kl"
 (__ref0)->isClass = false; 

#line 1093 "klparse.cpp"
} break;
case 23: {
Parser_Lel_inline_list *__ref0 = (Parser_Lel_inline_list*)&rhs[3]->user.inline_list;
Parser_Lel_inline_list *__ref1 = (Parser_Lel_inline_list*)&rhs[3]->user.inline_list;
Token *__ref2 = (Token*)&rhs[2]->user.token;
Token *__ref3 = (Token*)&rhs[2]->user.token;
Token *__ref4 = (Token*)&rhs[2]->user.token;
Parser_Lel_opt_class *__ref5 = (Parser_Lel_opt_class*)&rhs[1]->user.opt_class;
#line 155 "klparse.kl"

		/* Create the inline block and create/get the typedef. */
		InlineBlock *typeBlock = new InlineBlock( InputLoc((__ref0)->loc), (__ref1)->inlineList );
		TypeDef *typeDef = getTypeDef( (__ref2)->data );

		/* The typeDef should not already exist. */
		if ( typeDef->typeBlock != 0 )
			error((__ref3)->loc) << "redefintion of nonterminal type " << (__ref4)->data << endl;
		else {
			typeDef->typeBlock = typeBlock;
			typeDef->isClass = (__ref5)->isClass;
		}
	

#line 1117 "klparse.cpp"
} break;
case 24: {
Token *__ref0 = (Token*)&rhs[1]->user.token;
#line 171 "klparse.kl"

		KlangEl *nonTerm = getKlangEl( &pd, (__ref0)->data, KlangEl::NonTerm );
		nonTerm->isShortest = true;
	

#line 1127 "klparse.cpp"
} break;
case 25: {
Parser_Lel_inline_list *__ref0 = (Parser_Lel_inline_list*)&rhs[0]->user.inline_list;
Parser_Lel_inline_block_item *__ref1 = (Parser_Lel_inline_block_item*)&rhs[1]->user.inline_block_item;
Parser_Lel_inline_list *__ref2 = (Parser_Lel_inline_list*)&redLel->user.inline_list;
Parser_Lel_inline_list *__ref3 = (Parser_Lel_inline_list*)&rhs[0]->user.inline_list;
Parser_Lel_inline_list *__ref4 = (Parser_Lel_inline_list*)&redLel->user.inline_list;
Parser_Lel_inline_list *__ref5 = (Parser_Lel_inline_list*)&rhs[0]->user.inline_list;
#line 185 "klparse.kl"

		(__ref0)->inlineList->append( (__ref1)->inlineItem );
		(__ref2)->inlineList = (__ref3)->inlineList;
		(__ref4)->loc = (__ref5)->loc;
	

#line 1143 "klparse.cpp"
} break;
case 26: {
Parser_Lel_inline_list *__ref0 = (Parser_Lel_inline_list*)&redLel->user.inline_list;
Parser_Lel_inline_list *__ref1 = (Parser_Lel_inline_list*)&redLel->user.inline_list;
Parser_Lel_inline_block_item *__ref2 = (Parser_Lel_inline_block_item*)&rhs[0]->user.inline_block_item;
Parser_Lel_inline_list *__ref3 = (Parser_Lel_inline_list*)&redLel->user.inline_list;
Parser_Lel_inline_block_item *__ref4 = (Parser_Lel_inline_block_item*)&rhs[0]->user.inline_block_item;
#line 193 "klparse.kl"

		(__ref0)->inlineList = new InlineList;
		(__ref1)->inlineList->append( (__ref2)->inlineItem );
		(__ref3)->loc = (__ref4)->loc;
	

#line 1158 "klparse.cpp"
} break;
case 27: {
Parser_Lel_inline_block_item *__ref0 = (Parser_Lel_inline_block_item*)&redLel->user.inline_block_item;
Token *__ref1 = (Token*)&rhs[0]->user.token;
Token *__ref2 = (Token*)&rhs[0]->user.token;
Parser_Lel_inline_block_item *__ref3 = (Parser_Lel_inline_block_item*)&redLel->user.inline_block_item;
Token *__ref4 = (Token*)&rhs[0]->user.token;
#line 207 "klparse.kl"

		(__ref0)->inlineItem = new InlineItem( (__ref1)->loc, (__ref2)->data, InlineItem::Text );
		(__ref3)->loc = (__ref4)->loc;
	

#line 1172 "klparse.cpp"
} break;
case 28: {
Parser_Lel_inline_block_item *__ref0 = (Parser_Lel_inline_block_item*)&redLel->user.inline_block_item;
Token *__ref1 = (Token*)&rhs[0]->user.token;
Token *__ref2 = (Token*)&rhs[0]->user.token;
Parser_Lel_inline_block_item *__ref3 = (Parser_Lel_inline_block_item*)&redLel->user.inline_block_item;
Token *__ref4 = (Token*)&rhs[0]->user.token;
#line 214 "klparse.kl"

		(__ref0)->inlineItem = new InlineItem( (__ref1)->loc, (__ref2)->data, InlineItem::Reference );
		(__ref3)->loc = (__ref4)->loc;
	

#line 1186 "klparse.cpp"
} break;
case 29: {
Parser_Lel_prod_el_list *__ref0 = (Parser_Lel_prod_el_list*)&rhs[0]->user.prod_el_list;
Parser_Lel_prod_el *__ref1 = (Parser_Lel_prod_el*)&rhs[1]->user.prod_el;
Parser_Lel_prod_el_list *__ref2 = (Parser_Lel_prod_el_list*)&redLel->user.prod_el_list;
Parser_Lel_prod_el_list *__ref3 = (Parser_Lel_prod_el_list*)&rhs[0]->user.prod_el_list;
#line 226 "klparse.kl"

		(__ref0)->prodElList->append( (__ref1)->factor );
		(__ref2)->prodElList = (__ref3)->prodElList;
	

#line 1199 "klparse.cpp"
} break;
case 30: {
Parser_Lel_prod_el_list *__ref0 = (Parser_Lel_prod_el_list*)&redLel->user.prod_el_list;
#line 232 "klparse.kl"
 (__ref0)->prodElList = new ProdElList; 

#line 1206 "klparse.cpp"
} break;
case 31: {
Token *__ref0 = (Token*)&rhs[2]->user.token;
Parser_Lel_prod_el *__ref1 = (Parser_Lel_prod_el*)&redLel->user.prod_el;
Token *__ref2 = (Token*)&rhs[2]->user.token;
Parser_Lel_opt_commit *__ref3 = (Parser_Lel_opt_commit*)&rhs[1]->user.opt_commit;
Parser_Lel_opt_prior *__ref4 = (Parser_Lel_opt_prior*)&rhs[0]->user.opt_prior;
Parser_Lel_prod_el *__ref5 = (Parser_Lel_prod_el*)&redLel->user.prod_el;
#line 241 "klparse.kl"

		KlangEl *langEl = getKlangEl( &pd, (__ref0)->data, KlangEl::Unknown );
		(__ref1)->factor = new Factor( (__ref2)->loc, (__ref3)->commit, langEl, (__ref4)->priorVal );
		langElVect.append( langEl );
		factorVect.append( (__ref5)->factor );
	

#line 1223 "klparse.cpp"
} break;
case 32: {
Token *__ref0 = (Token*)&rhs[2]->user.token;
Token *__ref1 = (Token*)&rhs[2]->user.token;
Parser_Lel_prod_el *__ref2 = (Parser_Lel_prod_el*)&redLel->user.prod_el;
Token *__ref3 = (Token*)&rhs[2]->user.token;
Parser_Lel_opt_commit *__ref4 = (Parser_Lel_opt_commit*)&rhs[1]->user.opt_commit;
Parser_Lel_opt_prior *__ref5 = (Parser_Lel_opt_prior*)&rhs[0]->user.opt_prior;
Parser_Lel_prod_el *__ref6 = (Parser_Lel_prod_el*)&redLel->user.prod_el;
#line 250 "klparse.kl"

		/* Create a new factor node going to a concat literal. */
		Literal *literal = new Literal( (__ref0)->loc, (__ref1)->data[0] );
		(__ref2)->factor = new Factor( (__ref3)->loc, (__ref4)->commit, literal, (__ref5)->priorVal );
		langElVect.append( 0 );
		factorVect.append( (__ref6)->factor );
	

#line 1242 "klparse.cpp"
} break;
case 33: {
Parser_Lel_opt_commit *__ref0 = (Parser_Lel_opt_commit*)&redLel->user.opt_commit;
#line 264 "klparse.kl"
 (__ref0)->commit = false; 

#line 1249 "klparse.cpp"
} break;
case 34: {
Parser_Lel_opt_commit *__ref0 = (Parser_Lel_opt_commit*)&redLel->user.opt_commit;
#line 265 "klparse.kl"
 (__ref0)->commit = true; 

#line 1256 "klparse.cpp"
} break;
case 35: {
Parser_Lel_opt_prior *__ref0 = (Parser_Lel_opt_prior*)&redLel->user.opt_prior;
Token *__ref1 = (Token*)&rhs[2]->user.token;
#line 273 "klparse.kl"
 
		(__ref0)->priorVal = atoi( (__ref1)->data );
	

#line 1266 "klparse.cpp"
} break;
case 36: {
Parser_Lel_opt_prior *__ref0 = (Parser_Lel_opt_prior*)&redLel->user.opt_prior;
#line 277 "klparse.kl"
 (__ref0)->priorVal = 0; 

#line 1273 "klparse.cpp"
} break;
case 37: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
#line 290 "klparse.kl"
 (__ref0)->inlineBlock = 0; 

#line 1280 "klparse.cpp"
} break;
case 38: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
Parser_Lel_inline_list *__ref1 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
Parser_Lel_inline_list *__ref2 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
#line 293 "klparse.kl"
 
		(__ref0)->inlineBlock = new InlineBlock( (__ref1)->loc, (__ref2)->inlineList );
	

#line 1291 "klparse.cpp"
} break;
case 39: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
#line 297 "klparse.kl"
 (__ref0)->inlineBlock = 0; 

#line 1298 "klparse.cpp"
} break;
case 40: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
Parser_Lel_inline_list *__ref1 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
Parser_Lel_inline_list *__ref2 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
#line 300 "klparse.kl"
 
		(__ref0)->inlineBlock = new InlineBlock( (__ref1)->loc, (__ref2)->inlineList );
	

#line 1309 "klparse.cpp"
} break;
case 41: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
#line 304 "klparse.kl"
 (__ref0)->inlineBlock = 0; 

#line 1316 "klparse.cpp"
} break;
case 42: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
Parser_Lel_inline_list *__ref1 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
Parser_Lel_inline_list *__ref2 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
#line 307 "klparse.kl"
 
		(__ref0)->inlineBlock = new InlineBlock( (__ref1)->loc, (__ref2)->inlineList );
	

#line 1327 "klparse.cpp"
} break;
case 43: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
#line 311 "klparse.kl"
 (__ref0)->inlineBlock = 0; 

#line 1334 "klparse.cpp"
} break;
case 44: {
Parser_Lel_opt_inline_block *__ref0 = (Parser_Lel_opt_inline_block*)&redLel->user.opt_inline_block;
Parser_Lel_inline_list *__ref1 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
Parser_Lel_inline_list *__ref2 = (Parser_Lel_inline_list*)&rhs[1]->user.inline_list;
#line 314 "klparse.kl"
 
		(__ref0)->inlineBlock = new InlineBlock( (__ref1)->loc, (__ref2)->inlineList );
	

#line 1345 "klparse.cpp"
} break;
}
			}

			if ( lel->child != 0 ) {
				struct Parser_LangEl *first = lel->child;
				struct Parser_LangEl *child = lel->child;
				lel->child = 0;
				while ( 1 ) {
					if ( child->type < 152 ) {
					}
					else {
					}
					numNodes -= 1;
					if ( child->next == 0 )
						break;
					child = child->next;
				}
				child->next = pool;
				pool = first;
			}
		}

commit_base:
		if ( sp > 0 ) {
			sp -= 1;
			if ( lel->retry == 0 ) {
				lel = lel->prev;
				goto commit_reverse;
			}
			else {
				lel->retry = 0;
				lel = lel->prev;
				goto commit_upwards;
			}
		}
		lel->retry = 0;

		lastFinal = lel;
		numRetry = 0;
	}

	if ( *action & 0x2 ) {
		int reduction = *action >> 2;
		struct Parser_LangEl *redLel;

		if ( input != 0 )
			input->causeReduce += 1;

	if ( pool == 0 ) {
		if ( freshPos == 8128 ) {
			struct Parser_Block* newBlock  = (struct Parser_Block*) malloc( sizeof(struct Parser_Block) );
			newBlock->next = block;
			block = newBlock;
			freshEl = newBlock->data;
			#ifdef KELBT_LOG_ACTIONS
			cerr << "allocating 8128 LangEls" << endl;
			#endif
			freshPos = 0;
		}
		redLel = freshEl + freshPos++;
	}
	else {
		redLel = pool;
		pool = pool->next;
	}
	numNodes += 1;

		redLel->type = Parser_prodLhsIds[reduction];
		redLel->reduction = reduction;
		redLel->child = 0;
		redLel->next = 0;
		redLel->retry = (lel->retry << 16);
		redLel->causeReduce = 0;
		lel->retry &= 0xffff0000;

		rhsLen = Parser_prodLengths[reduction];
		if ( rhsLen > 0 ) {
			int r;
			for ( r = rhsLen-1; r > 0; r-- ) {
				rhs[r] = stackTop;
				stackTop = stackTop->next;
			}
			rhs[0] = stackTop;
			stackTop = stackTop->next;
			rhs[0]->next = 0;
		}
		#ifdef KELBT_LOG_ACTIONS
		cerr << "reduced: "
				<< Parser_prodNames[reduction]
				<< " rhsLen: " << rhsLen;
		#endif
		if ( action[1] == 0 )
			redLel->retry = 0;
		else {
			redLel->retry += 0x10000;
			numRetry += 1;
			#ifdef KELBT_LOG_ACTIONS
			cerr << " retry: " << redLel;
			#endif
		}

		#ifdef KELBT_LOG_ACTIONS
		cerr << endl;
		#endif

		if ( rhsLen == 0 ) {
			redLel->file = lel->file;
			redLel->line = lel->line;
			targState = curs;
		}
		else {
			redLel->child = rhs[rhsLen-1];
			redLel->file = rhs[0]->file;
			redLel->line = rhs[0]->line;
			targState = rhs[0]->state;
		}

		if ( induceReject ) {
			#ifdef KELBT_LOG_ACTIONS
			cerr << "error induced during reduction of " <<
					Parser_lelNames[redLel->type] << endl;
			#endif
			redLel->state = curs;
			redLel->next = stackTop;
			stackTop = redLel;
			curs = targState;
			goto parseError;
		}
		else {
			redLel->next = input;
			input = redLel;
		}
	}


	curs = targState;
	goto again;

parseError:
	#ifdef KELBT_LOG_BACKTRACK
	cerr << "hit error" << endl;
	#endif
	if ( numRetry > 0 ) {
		struct Parser_LangEl *redLel;

		if ( input != 0 ) {
			redLel = input;
			goto have_undo_element;
		}

		while ( 1 ) {
			redLel = stackTop;
			if ( stackTop->type < 152 ) {
				#ifdef KELBT_LOG_BACKTRACK
				cerr << "backing up over terminal: " <<
						Parser_lelNames[stackTop->type] << endl;
				#endif
				stackTop = stackTop->next;
				redLel->next = input;
				input = redLel;
			}
			else {
				#ifdef KELBT_LOG_BACKTRACK
				cerr << "backing up over non-terminal: " <<
						Parser_lelNames[stackTop->type] << endl;
				#endif
				stackTop = stackTop->next;
				struct Parser_LangEl *first = redLel->child;
				if ( first == 0 )
					rhsLen = 0;
				else {
					rhsLen = 1;
					while ( first->next != 0 ) {
						first = first->next;
						rhsLen += 1;
					}
					first->next = stackTop;
					stackTop = redLel->child;

					struct Parser_LangEl *rhsEl = stackTop;
					int p = rhsLen;
					while ( p > 0 ) {
						rhs[--p] = rhsEl;
						rhsEl = rhsEl->next;
					}
				}
				redLel->next = pool;
				pool = redLel;
				numNodes -= 1;

				if ( input != 0 )
					input->causeReduce -= 1;
			}

have_undo_element:
			if ( redLel->retry == 0 ) {
				if ( input != 0 && input->causeReduce == 0 ) {
					#ifdef KELBT_LOG_BACKTRACK
					cerr << "pushing back: " << Parser_lelNames[input->type] << endl;
					#endif
					input->next = queue;
					queue = input;
					input = 0;
				}
			}
			else {
				#ifdef KELBT_LOG_BACKTRACK
				cerr << "found retry targ: " << redLel << endl;
				#endif
				numRetry -= 1;
				#ifdef KELBT_LOG_BACKTRACK
				cerr << "found retry: " << redLel << endl;
				#endif
				if ( redLel->retry & 0x0000ffff )
					curs = input->state;
				else {
					input->retry = redLel->retry >> 16;
					if ( stackTop->state < 0 )
						curs = Parser_startState;
					else {
						curs = Parser_targs[(int)Parser_indicies[Parser_offsets[stackTop->state] + (stackTop->type - Parser_keys[stackTop->state<<1])]];
					}
				}
				goto again;
			}
		}
	}
	curs = -1;
	errCount += 1;
_out: {}
#line 342 "klparse.kl"
	return errCount == 0 ? 0 : -1;
}

int Parser::token( int line, int tokid, char *data )
{
	Token token;
	token.data = data;
	token.loc.line = line;
	token.loc.col = 1;

	//cout << "SENDING TOKEN: " << lelNames[tokid];
	//if ( token.data != 0 )
	//	cout << " data: " << token.data;
	//cout << endl;

	return parseLangEl( tokid, &token );
}
